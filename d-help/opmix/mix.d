/**
   Provide some standard mixins. For background on the point of this see an
   interesting thread:
   http://forum.dlang.org/post/iphhuttpkogmfwpuvfla@forum.dlang.org
   
   Overcomes this problem:
   
   	writeln(  [1: 2]  ==   [1: 2] );  // true
   	writeln(S([1: 2]) == S([1: 2]));  // false
   
   by allowing:
   
   	writeln(typesDeepEqual(S([1: 2]), S([1: 2]))); // true
   
   and allowing:
   
   struct S {
     mixin(OpEquals);
     int[int] _m;
   }
   
   to give:
   
   	writeln(S([1: 2]) == S([1: 2]));  // now true false
   
   Provides other mixins like: OpEquals, PostBlit, OpCmp, Dup, Deep, ToHash, 
   HashSupport
*/

module opmix.mix;

import std.algorithm;
import std.math;
import std.string;
import std.traits;

/**
   Set this to true to see what is going on at compile time
*/
const(bool) LogCompile = false;

const(string) OpEquals = `
bool opEquals(const ref typeof(this) other) const {
  mixin(LogInfo("opEquals by ref ", "typeof(this)", "this"));
  return typesDeepEqual(this, other);
}

bool opEquals(const typeof(this) other) const {
  mixin(LogInfo("opEquals by val ", "typeof(this)", "this"));
  return typesDeepEqual(this, other);
}
`
;

/**
   Mixin to provide reasonable opCmp. It deeply compares the fields of
   the struct and assumes member structs have suitable opCmp. Use
   this, for example, to enable storing instances in a RedBlackTree.
*/
const(string) OpCmp = `
int opCmp(const ref typeof(this) other) const {
  return typesDeepCmp(this, other);
}

int opCmp(const typeof(this) other) const {
  return typesDeepCmp(this, other);
}
`
;

/**
   Mixin to provide a reasonable dup. dup is not really part of the
   language but rather a convention used to copy items that have
   aliasing/sharing. For example, dynamic arrays, associative,
   BitArray, HTTP have dup defined since a basic assignment of them
   introduces sharing. So if you want your class to have aliasing but
   still want an out mixin(Dup) and don't bother with mixin(PostBlit).
*/
const(string) Dup = `

  @property auto idup() const {
    return cast(immutable(typeof(this)))this.dup;
  }

  @property auto dup() const {
    Unqual!(typeof(this)) temp;
    gdup(temp, this);
    return temp;
  }
`;

/**
   Mixin to provide both a post blit and opEquals which usually go
   together.
*/
const(string) Deep = `
  mixin(PostBlit);
  mixin(OpEquals);
`;

/**
   Mixin to provide a this(this). This is very similar to dup in that
   it calls dup on all dupable fields of the struct. Decide up front
   if you want deep semantics (i.e. assignment will make deep copies
   of all members) on your struct. If you do, use this to get
   that. This is only useful if one or more of your fields require
   deep copy (like associative arrays, arrays, other classes with
   dup). If you are ok with shallow semantics, forego this and
   consider using mixin(Dup) to allow for deep copy. If you decide to
   go the PostBlit route, you probably need an opEquals with deep
   comparison. So consider mixin(DeepSemantics) wich includes
   mixin(PostBlit) and mixin(OpEquals).
*/
const(string) PostBlit = `
this(this) {
    alias typeof(this) T;
    foreach (i, field ; typeof(T.tupleof)) {
      alias typeof(T.tupleof[i]) FieldType;
      static if(isDynamicArray!(FieldType) &&
                isArrayOfImmutable!FieldType) {
        static if(LogCompile) 
          pragma(msg, 
                 "CT: No needless duping of immutable element type arr ", 
                 T.tupleof[i]); 
      } else static if(isPointer!(FieldType) || 
                       isDynamicArray!(FieldType) ||
                       isAssociativeArray!(FieldType) ||
                       HasDup!FieldType) {
        gdup(this.tupleof[i], this.tupleof[i]);
      } else static if(hasAliasing!FieldType) {
        static if(LogCompile) 
          pragma(msg, 
                 "CT: Postblit of ", T, " drilling down on ", 
                 T.tupleof[i].stringof);
        gdup(this.tupleof[i], this.tupleof[i]);
      } else {
        static if(LogCompile) 
          pragma(msg, 
                 "CT: Postblit of ", T, " ignoring ", 
                 T.tupleof[i].stringof);
      }
    }
  }
`;

/**
   Mixin to provide toHash for a struc that incorporates some aspect of all
   fields to the function.
*/
const(string) ToHash = `
  /**
    Hashing function hitting all data - mileage may vary.
    TODO: Make this and deepHash pure when foreach iteration permits
   */
  hash_t toHash() const nothrow {
    return deepHash!(typeof(this))(this);
  }
`;

/**
   Mixin to provide hashing functionality on a struct. For example, to
   make your struct usable as a key in an associative array you need
   to provide suitable and consistent toHash, opCmp, and
   opEquals. This mixin pulls in all three.
   
   According to the language spec: 
   
   'The implementation may use either opEquals or opCmp or both. Care
   should be taken so that the results of opEquals and opCmp are
   consistent with each other when the class objects are the same or
   not.'
   
   It is not clear whether that means you can leave opCmp out and it
   is capable of using opEquals alone... I had trouble there, so both
   are pulled in.
   
   In terms of performance, the point of the hash function is to get a
   good distribution. This implementation may be very expensive to
   compute compared to other custom hashes and it may not provide a
   good distribution. But you should be able to store HashSupport
   structs in a hash.
*/
const(string) HashSupport = `
  mixin(OpEquals);
  mixin(OpCmp);
  mixin(ToHash);
`;


// custom <dmodule mix public_section>

/** 
  For debugging, logs a compile time message at various points. If mixing in
  OpEquals or hashing and there are compile errors, maybe something in the
  struct is missing. The compile time logs help determine at what stage
  compilation goes off the rails.  To enable set LogCompile to true.
*/
string LogInfo(string tag, string T, string instance) { 
  return `
  static if(LogCompile) {
    pragma(msg, "CT: `~tag~`", `~T~`);
  }
  `;
}

/** Discriminates a pass type by its size
 */
template PrefersPassByRef(T) {
  static if(T.sizeof > 16 || hasAliasing!T) {
    enum PrefersPassByRef = true;
  } else {
    enum PrefersPassByRef = false;
  }
}

/** Discriminates a pass type by its size
 */
template PreferredPassType(T) {
  static if(PrefersPassByRef!T) {
    enum PreferredPassType = `const ref `~T.stringof;
  } else {
    enum PreferredPassType = T.stringof;
  }
}

/** Provides mixin for making a field read only.
 *  For example mixin(ReadOnly!_fieldName) provides a getter named fieldName.
 */
template ReadOnly(alias name) {
  enum v = name.stringof;
  enum p = name.stringof[1..$];
  enum prefersReference = PrefersPassByRef!(typeof(name));
  static if(prefersReference) {
    enum ReadOnly = `
public @property auto `~p~`() const { 
  return `~v~`; 
}
`;
  } else {
    enum ReadOnly = `
public @property ref auto `~p~`() const { 
  return `~v~`; 
}
`;
  }
}

/** Provides mixin for the *read* accessor when making a field read/write.
 * Don't be a liar - provide your own write accessor.
 */
template ReadWrite(alias name) {
  enum ReadWrite = ReadOnly!name;
}

@property auto gdup(T)(const ref T t) {
  DeepUnqual!T result;
  static if(LogCompile) 
    pragma(msg, 
           "CT: gdup prop on (", 
           typeof(result), " <= ", typeof(t), ")");
  gdup(result, t);
  return result;
}

void gdup(T1, T2)(ref T1 t1, const ref T2 t2) {
  static assert(is(Unqual!(typeof(t1)) == typeof(t1)), 
                "Must dup into mutable "~typeof(t1).stringof~
                " <= "~typeof(t2).stringof);

  static if(LogCompile) 
    pragma(msg, 
           "CT: gdup(t1,t2) prop on (", 
           typeof(t1), " <= ", typeof(t2), ")");

  static if(isBasicType!T1 || is(T1==enum)) {
    static if(LogCompile) 
      pragma(msg, "CT: ...T1 is basic type ", T1);
    t1 = t2;
  } else static if(isArrayOfImmutable!T1 && isArrayOfImmutable!T2) {
    static if(LogCompile) 
      pragma(msg, "CT: ...T1 is array of immutable ", T1, " as is t2 ", T2);
    t1 = t2.idup;
  } else static if(isDynamicArray!T1) {
    static if(hasAliasing!(ArrayElementType!T1)) {
      static if(LogCompile) 
        pragma(msg, "CT: ...T1 is array mutable ", T1);
      // If gdup is being called from postblit then t1 is t2 and we need
      // to have a fresh temp to copy into
      typeof(t1) temp;
      bool isPostBlit = (t1 is t2);
      typeof(t1) *bestChoice = isPostBlit? &temp : &t1;
      (*bestChoice).clear();
      foreach(ref val2; t2) {
        Unqual!(ArrayElementType!T1) val1;
        opDupPreferred(val1, val2);
        (*bestChoice) ~= val1;
      }
      if(isPostBlit) {
        swap(t1, temp);
      }
    } else {
      static if(LogCompile) 
        pragma(msg, "CT: ...T1 is array of type with no aliasing ", T1);
      t1 = t2.dup;
    }
  } else static if(isAssociativeArray!T1) {
    static if(LogCompile) 
      pragma(msg, "CT: ...T1 is assoc array ", T1, 
             " w value type ", ValueType!T1, " aka ", typeof(t1));

    alias KeyType!(T1) AAKeyType;
    alias ValueType!(T1) AAValueType;
    alias DeepUnqual!(AAValueType)[DeepUnqual!(AAKeyType)] NoConstAssocArr;
    typeof(t1) temp;
    bool isPostBlit = ((cast(DeepUnqual!T1)t1) is (cast(DeepUnqual!T2)t2));
    typeof(t1) *bestChoice = isPostBlit? &temp : &t1;
    if(!isPostBlit) (*bestChoice).clear();
    // NOTE: k here *is* copied with postblit, which is a shame. It would be
    // better if the foreach would be like
    // foreach(ref const(K) k, ref V v2; ...)
    // foreach(ref const(K) k, ref const(V) v2; ...)
    // per the user's choosing
    foreach(k, ref v2; cast(DeepUnqual!(typeof(t2)))t2) {
      AAValueType v1;
      opDupPreferred(v1, v2);
      (*bestChoice)[k] = v1;
    }
    if(isPostBlit) {
      swap(t1, temp);
    }
    static if(LogCompile) pragma(msg, "CT: ...T1 done assoc array ", T1);
  } else static if(is(T1==struct)) {
    static if(LogCompile) pragma(msg, "CT: ...T1 is struct ", T1);
      Unqual!(typeof(t1)) temp;
      bool isPostBlit = t1 is t2;
      typeof(t1) *bestChoice = isPostBlit? &temp : &t1;
      foreach (i, ignore ; typeof(T1.tupleof)) {
        static if(T1.tupleof[i].stringof.endsWith(".this")) {
          static assert(0, "no dup of nested non static structs!");
        }
        static if(LogCompile) 
          pragma(msg, "CT: .....dupping field ", t2.tupleof[i].stringof);
        opDupPreferred((*bestChoice).tupleof[i], t2.tupleof[i]);
      }
      if(isPostBlit) {
        swap(t1, temp);
      }
  } else static if(isPointer!T1) {
    static if(LogCompile) pragma(msg, "CT: ...T1 is pointer ", T1);
    alias Unqual!(PointerTarget!T1) Target;
    if(t2) {
      static if(__traits(compiles, (t1 = new Target))) {
        t1 = new Target;
        opDupPreferred(*t1, *t2); 
      } else {
        static assert(0, "gdup will not work with "~
                      Target.stringof~
                      " since can not be default heap allocated");
      }
    }
  } else static if(is(T1==union)) {
      t1 = t2;
  } else static if(is(T1==class)) {
    static if(LogCompile) 
      pragma(msg, "CT: ...T1 is a class else entirely ", T1);
    static assert(0, "Class gdup not supported, requested type "~T1.stringof);
  } else {
    static assert(0, "Missing gdup support for "~T1.stringof);
  }
}

/** Compare for equality all fields in a class
    Original courtesy of Tobias Pankrath
    Updated to use tupleof instead of getMember and short circuits
    Supports associative and dynamic arrays
    Treats default float.init as equal
 */
bool typesDeepEqual(T,F)(auto ref T lhs, auto ref F rhs)
  if(is(DeepUnqual!T == DeepUnqual!F)) {
  mixin(LogInfo("typesDeepEqual by ref ", "T", "lhs"));
  bool result = true;

  if(lhs is rhs) { return true; }

  static if(isFloatingPoint!(T)) {
    mixin(LogInfo("...typesDeepEqual floating ", "T", "lhs"));
    if(!isnan(lhs) || !isnan(rhs)) {
        result &= lhs == rhs;  
    }
    // both nan, assume equal - maybe should make configurable
  } else static if(isPointer!(T)) {
    mixin(LogInfo("...typesDeepEqual pointer ", "T", "lhs"));
    if(lhs && rhs) {
      result &= typesDeepEqual(*lhs, *rhs);
    } else {
      result = !(lhs || rhs);
    }
  } else static if(isAssociativeArray!(T)) {
    mixin(LogInfo("...typesDeepEqual assoc array ", "T", "lhs"));

    ///// TODO: Remove const casts on length and keys when no longer
    ///// necessary. Note: important to cast away const on both key and
    ///// value.
    alias KeyType!(T) AAKeyType;
    alias ValueType!(T) AAValueType;
    alias Unqual!(AAValueType)[Unqual!(AAKeyType)] NoConstAssocArr;
    if((cast(NoConstAssocArr)lhs).length != (cast(NoConstAssocArr)rhs).length) return false;
    auto lhsKeys = (cast(NoConstAssocArr)lhs).keys;
    auto rhsKeys = (cast(NoConstAssocArr)rhs).keys;

    lhsKeys.sort;
    rhsKeys.sort;
    for(size_t i=0; i<lhsKeys.length; ++i) {
        if(!typesDeepEqual(lhsKeys[i], rhsKeys[i])) return false;
        const(AAValueType)* lvalue = lhsKeys[i] in lhs;
        const(AAValueType)* rvalue = rhsKeys[i] in rhs;
        if(!((lvalue && rvalue)? typesDeepEqual(*lvalue, *rvalue) : lvalue == rvalue)) return false;
    }
  } else static if(isDynamicArray!(T)) {
    mixin(LogInfo("...typesDeepEqual dynamic array ", "T", "lhs"));
    auto llen = lhs.length, rlen = rhs.length;
    auto end = min(llen, rlen);
    for(size_t i=0; i<end; ++i) {
      if(!typesDeepEqual(lhs[i], rhs[i])) return false;
    }
    result = llen == rlen;
  } else static if(is(T == struct)) {
    mixin(LogInfo("...typesDeepEqual struct ", "T", "lhs"));
    foreach (i, ignore ; typeof(T.tupleof)) {
      mixin(LogInfo("struct field <"~lhs.tupleof[i].stringof~">", "T.tupleof[i]", "lhs.tupleof[i]"));
      alias typeof(T.tupleof[i]) FieldType;
      static if(T.tupleof[i].stringof.endsWith(".this")) {
        // Skip if nested class
      } else {
        // Special case pointed out by Tobias
        static if(isPointer!FieldType && is(PointerTarget!FieldType == T)) {
          auto l = lhs.tupleof[i];
          auto r = rhs.tupleof[i];
          if((l && ((*l).tupleof[i] == rhs.tupleof[i])) &&
             (r && ((*r).tupleof[i] == lhs.tupleof[i]))) {
            // let it ride
          } else {
            result &= typesDeepEqual(l, r);
          }
        } else {
          result &= typesDeepEqual(lhs.tupleof[i], rhs.tupleof[i]);
        }
      }
      if(!result) return false;
    }
  } else {
    mixin(LogInfo("...typesDeepEqual catch-all ", "T", "lhs"));
    result = lhs == rhs;
  }
  return result;
}

ref T opDupPreferred(T, F)(ref T target, const ref F src)
  if(is(DeepUnqual!T == DeepUnqual!F)) {
  static if(LogCompile) 
    pragma(msg, 
           "CT: opDupPreferred on (", typeof(target), " <= ", typeof(src), ")");
  static if(is(T==struct) && __traits(compiles, (src.dup))) {
    static if(LogCompile) 
      pragma(msg, 
             "CT: ...Using ", 
             typeof(src).stringof, ".dup for dup of ", typeof(src));
    target = src.dup;
  } else {
    static if(LogCompile) 
      pragma(msg, "CT: ...Using gdup for dup of ", typeof(src));
    gdup(target, src);
  }
  return target;
}

int opCmpPreferred(T, F)(const ref T lhs, const ref F rhs) {
  static if(__traits(compiles, (lhs.opCmp(rhs)))) {
    return lhs.opCmp(rhs);
  } else {
    return typesDeepCmp(lhs, rhs);
  }
}

/** Compare all fields for suitable opCmp.
    Order will be that returned by T.tupleof
 */
int typesDeepCmp(T,F)(auto ref T lhs, auto ref F rhs)
  if(is(DeepUnqual!T == DeepUnqual!F)) {

  static if(isFloatingPoint!(T)) {
    if(isnan(lhs) && isnan(rhs)) { return 0; }
    return (lhs<rhs)? -1 : (lhs>rhs)? 1 : 0;
  } else static if(isSomeString!T) {
    return lhs.cmp(rhs);
  } else static if(is(T == struct)) {
      foreach (i, ignore ; typeof(T.tupleof)) {
        static if(T.tupleof[i].stringof.endsWith(".this")) {
          // Skip if nested class
        } else {
          int result = opCmpPreferred(lhs.tupleof[i], rhs.tupleof[i]);
          if(result) return result;
        }
      }
      return 0;
  } else static if(isPointer!(T)) {
      int result;
      if(lhs && rhs) {
        result = opCmpPreferred(*lhs, *rhs);
      } else {
        result = rhs? -1 : lhs? 1 : 0;
      }
      return result;
  } else static if(isAssociativeArray!(T)) {
    ///// TODO: Remove const casts on keys
    // Compare keys in order
    alias Unqual!(ValueType!T)[Unqual!(KeyType!T)] NoConstAssocArr;
    auto lhsKeys = (cast(NoConstAssocArr)lhs).keys.dup;
    auto rhsKeys = (cast(NoConstAssocArr)rhs).keys.dup;
    if(lhsKeys.length != rhsKeys.length) return false;

    lhsKeys.sort;
    rhsKeys.sort;

    auto keysCmp = cmp(lhsKeys, rhsKeys);
    if(keysCmp) { return keysCmp; }

    foreach(ref key; lhsKeys) {
      auto lhsVal = key in lhs;
      auto rhsVal = key in rhs;

      if(lhsVal && rhsVal) { 
        auto result = opCmpPreferred(*lhsVal, *rhsVal);
        if(result) return result;
      } else if(rhsVal) { 
        return -1;
      } else { 
        return 1;
      }
    }

    return 0;
  } else {
    return (lhs < rhs)? -1 : (lhs > rhs)? 1 : 0;
  }
}

hash_t toHashPreferred(T)(const ref T t) nothrow {
  static if(is(T==struct) && __traits(compiles, (t.toHash()))) {
    return t.toHash();
  } else {
    return deepHash(t);
  }
}

/**

  Computes a hash taking into account all fields. A good question in a long
  thread was posed here
  http://forum.dlang.org/post/jiweknaxeaeepjlvhrlf@forum.dlang.org

  This uses the same ideas and provides function to wrap as mixin.

 */
hash_t deepHash(T)(const ref T t) nothrow { 
  const int prime = 23;
  hash_t result = 17;
  static if(isPointer!T) {
    mixin(LogInfo("Hashing ptr ", "T", "t"));
    if(t) {
      result = result*prime + deepHash(*t);
    }
  } else static if(isAssociativeArray!T) {
    try {
      foreach(key, value; t) {
        mixin(LogInfo("Hashing assoc array ", "T", "t"));
        result = result*prime + deepHash(key);
        result = result*prime + deepHash(value);
      }
    } catch(Exception) {
      assert(0);
    }
  } else static if(isSomeString!(T)) {
    mixin(LogInfo("Hashing string ", "T", "t"));
    result = result*prime + typeid(T).getHash(&t);
  } else static if(isArray!T) {
    mixin(LogInfo("Hashing array ", "T", "t"));
    size_t end = t.length;
    for(size_t i=0; i<end; ++i) {
      result = result*prime + toHashPreferred(t[i]);
    }
  } else static if (isIntegral!(T) || isSomeChar!(T) || 
                    isBoolean!(T) || is(T==enum)) {
    mixin(LogInfo("Hashing integral, char, bool, enum ", 
                  "T", "t"));
    result = result*prime + t;
  } else static if (isFloatingPoint!(T)) {
    mixin(LogInfo("Hashing floating point ", "T", "t"));
    if(isnan(t)) { 
      result = result*prime + prime;
    } else {
      byte[T.sizeof] *buff = cast(byte[T.sizeof]*)&t;
      for(size_t i=0; i<T.sizeof; ++i) {
        result = result*prime + (*buff)[i];
      }
    }
  } else static if (is(T == struct) || is(T == class)) {
    mixin(LogInfo("Hashing struct ", "T", "t"));
    static if(is(T == class)) {
      if(!t) {
        return result;
      }
    } 
    foreach (i, ignore ; typeof(T.tupleof)) {
      static if(T.tupleof[i].stringof.endsWith(".this")) {
      } else {
        result = result*prime + toHashPreferred(t.tupleof[i]);
      }
    }
  } else {
    static assert(0, "Add support for "~T);
  }

  return result;
}

template DeepUnqual(T) {
  static if(isAssociativeArray!T) {
    alias Unqual!(Unqual!(ValueType!T)[Unqual!(KeyType!T)]) DeepUnqual;    
  } else static if(isDynamicArray!T) {
    alias Unqual!(Unqual!(ArrayElementType!T)[]) DeepUnqual;
  } else static if(isPointer!T) {
    alias Unqual!(PointerTarget!T) * DeepUnqual;
  } else {
    alias Unqual!T DeepUnqual;
  }
}

template ArrayElementType(T : U[], U) {
  alias U ArrayElementType;
}

template HasDup(T) { 
  enum HasDup = __traits(hasMember, T, "dup"); 
}

template isArrayOfNonMutable(T) {
  static if(isDynamicArray!T && 
            (is(ArrayElementType!T == const) ||
             is(ArrayElementType!T == immutable))) {
    enum isArrayOfImmutable = true;
  } else {
    enum isArrayOfImmutable = false;
  }
}

template isArrayOfImmutable(T) {
  static if(isDynamicArray!T && is(ArrayElementType!T == immutable)) {
    enum isArrayOfImmutable = true;
  } else {
    enum isArrayOfImmutable = false;
  }
}

template IsImmutable(T) { 
  static if(is(T U == immutable U)) {
    enum IsImmutable = true;
  } else {
    enum IsImmutable = false;
  }
}

// end <dmodule mix public_section>

/**
   License: <a href="http://www.boost.org/LICENSE_1_0.txt">Boost License 1.0</a>.
*/
